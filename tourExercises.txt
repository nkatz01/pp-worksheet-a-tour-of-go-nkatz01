#1

	package main

	import (
		"fmt"
		"math"
	)

	func Sqrt(x float64) float64 {
		var z float64  = 1.0
		var newz float64
	 //fmt.Println(-0.99 <math.Pow(10,-5))
		//var x float64 = 2
		count :=0 
		for  newz = ((z + x /z) / 2); math.Abs(newz-z)>math.Pow(10,-5); count++ 	{
			// fmt.Println(math.Pow(10,-5))
			z = newz
			newz  = ((z + x /z) / 2)
		
			// newz -= (z*z - x) / (2*z)
			
			 
			 
			fmt.Println(count)
		}
		return newz
	}

	func main() {
		fmt.Printf("%f \n" ,Sqrt(2))
		//fmt.Println(Sqrt(2))
	}
		//val float64 =  math.Pow(10,-5)
		//va  float64 = math.Abs(val)







# 2

	package main

	import "golang.org/x/tour/pic"
	//import "math"

	func Pic(dx, dy int) [][]uint8 {
		
		arr := make([][]uint8, dy)
		for i := range arr {
			
			innerArr := make([]uint8, dx)
			for j := range innerArr{
				innerArr[j] = uint8((i+j)/2 )
				//innerArr[j] = uint8(math.Pow(float64(i),float64(j)))
				//innerArr[j] = uint8((ixj)/2 )
			}
			arr[i] = innerArr
		}
		return arr
	}

	func main() {
		pic.Show(Pic)
	}
	
#3
	
	package main

import (
	 
	
	"strings"
	"golang.org/x/tour/wc"
)

func WordCount(s string) map[string]int {
	
	 mp := make(map[string]int)
	arr := strings.Fields(s)
	for _ ,value := range arr {
		  _, ok := mp[value] 
		if ok {
			mp[value] = mp[value]+1	
		} else {
			mp[value]=1
		}
		
	}
	 
	return mp
}

func main() {
	wc.Test(WordCount)
}


#4

package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
	nMin2 :=0
	nMin1 :=1
	var oldFib int
	return func() int {

		oldFib= nMin2
		nMin2 = nMin1
		nMin1 = oldFib + nMin1
		
		return oldFib
		  	
	}
	
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}

#5

package main

import (
	"fmt"
	"strconv"
)

type IPAddr [4]byte

/*
func (ip IPAddr) String() string {

	return fmt.Sprintf("%d.%d.%d.%d ", ip[0],ip[1],ip[2],ip[3] )
}
*/
func (ip IPAddr) String() string {
	var st string
	for _, val := range ip {
		st += strconv.Itoa(int(val)) + "."
	}
	st = st[:len(st)-1]
	return fmt.Sprintf("%v ", st)
}
func main() {
	hosts := map[string]IPAddr{
		"loopback":  {255, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}

	for name, ip := range hosts {

		fmt.Printf("%v: %v\n", name, ip)
	}
}

#6

package main

import (
	"fmt"
	"math"
)

type ErrNegativeSqrt float64

func (e ErrNegativeSqrt) Error() string {

	return fmt.Sprintf("cannot Sqrt negative number: %v", float64(e))

}

func Sqrt(x float64) (float64, error) {
	if x < 0 {

		return 0, ErrNegativeSqrt(x)
	}

	var z float64 = 1.0
	var newz float64

	count := 0
	for newz = ((z + x/z) / 2); math.Abs(newz-z) > math.Pow(10, -5); count++ {

		z = newz
		newz = ((z + x/z) / 2)

		fmt.Println(count)
	}
	return newz, nil
}

func main() {

	format(Sqrt(2))
	format(Sqrt(-2))
}
func format(i float64, err error) {

	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("Sqrt is:", i)
	}
}

#7

package main
import (
 )
 import "golang.org/x/tour/reader"

type MyReader struct{}

 func (mr MyReader) Read(b []byte) (int,  error){
 
	b[0] = 'A'
	
	return 1, nil 
}


func main() {
 	reader.Validate(MyReader{})
	
}

#8

package main

import (
	"io"
	"os"
	"strings"

	"unicode"
)

type rot13Reader struct {
	r io.Reader
}

func (r13 rot13Reader) Read(b []byte) (n int, err error) {

	i, err := r13.r.Read(b)
	str := string(b)
	var deciphered string
	for _, l := range str {

		if !unicode.IsSpace(l) {
			if l <= 'm' {
				l = l + 13
			} else {
				l = l - 13
			}
		}
		deciphered += string(l)
	}

	copy(b, deciphered)
	return i, err
}

func main() {
	s := strings.NewReader("Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}

	io.Copy(os.Stdout, &r)

}



